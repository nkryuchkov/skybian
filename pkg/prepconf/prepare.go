package prepconf

import (
	"encoding/json"
	"io/ioutil"
	"log"
	"os"

	"github.com/skycoin/dmsg/cipher"
	"github.com/skycoin/skywire/pkg/app/launcher"
	"github.com/skycoin/skywire/pkg/hypervisor"
	"github.com/skycoin/skywire/pkg/restart"
	"github.com/skycoin/skywire/pkg/routing"
	"github.com/skycoin/skywire/pkg/skyenv"
	"github.com/skycoin/skywire/pkg/visor/visorconfig"

	"github.com/skycoin/skybian/pkg/boot"
)

// Config configures how hypervisor and visor images are to be generated.
type Config struct {
	VisorConf      string
	HypervisorConf string
	TLSCert        string
	TLSKey         string
}

// Prepare prepares either a hypervisor and visor config file (based on provided
// conf and boot parameters).
func Prepare(logger *log.Logger, conf Config, bp boot.Params) error {

	// generate config struct
	type genFn func(conf Config, bp boot.Params) (out interface{}, err error)

	// ensure config file of 'name' exists
	// if not, write config generated by 'genConfig'
	ensureExists := func(name string, genConfig genFn) error {
		//// Do nothing if file exists.
		if _, err := os.Stat(name); err == nil {
			conf, err := ioutil.ReadFile(name) //nolint:gosec
			if err == nil {
				logger.Printf("Contents of %q: %q", name, string(conf))
			}

			if len(conf) != 0 {
				logger.Printf("Config file %q already exists and is not empty", name)
				return nil
			}
		}
		// Create file.
		f, err := os.OpenFile(name, os.O_WRONLY|os.O_CREATE, 0644) //nolint:gosec
		if err != nil {
			return err
		}
		// Generate and write config to file.
		conf, err := genConfig(conf, bp)
		if err != nil {
			return err
		}
		raw, err := json.MarshalIndent(conf, "", "\t")
		if err != nil {
			return err
		}
		_, err = f.Write(raw)
		if err1 := f.Close(); err == nil {
			err = err1
		}
		return err
	}

	// config location and contents depend on mode
	switch bp.Mode {
	case boot.HypervisorMode:
		return ensureExists(conf.HypervisorConf, generateHypervisorConfig)
	case boot.VisorMode:
		return ensureExists(conf.VisorConf, generateVisorConfig)
	default:
		return boot.ErrInvalidMode
	}
}

func genKeyPair(bp boot.Params) (pk cipher.PubKey, sk cipher.SecKey, err error) {
	if sk = bp.LocalSK; sk.Null() {
		pk, sk = cipher.GenerateKeyPair()
	} else {
		pk, err = sk.PubKey()
	}
	return
}

func generateVisorConfig(_ Config, bp boot.Params) (interface{}, error) {
	skysocksArgs := func() (args []string) {
		if bp.SkysocksPasscode != "" {
			args = []string{"-passcode", bp.SkysocksPasscode}
		}
		return args
	}

	_, sk, err := genKeyPair(bp)
	if err != nil {
		return nil, err
	}

	out, err := visorconfig.MakeDefaultConfig(nil, "", &sk)
	if err != nil {
		return nil, err
	}

	// TODO(evanlinjin): We need to handle STCP properly.
	//if out.STCP, err = visor.DefaultSTCPConfig(); err != nil {
	//	return nil, err
	//}

	out.Dmsgpty.AuthFile = "/var/skywire-visor/dsmgpty/whitelist.json"
	out.Dmsgpty.CLIAddr = "/run/skywire-visor/dmsgpty/cli.sock"
	out.Transport.LogStore.Type = "file"
	out.Transport.LogStore.Location = "/var/skywire-visor/transports"
	out.Hypervisors = bp.HypervisorPKs
	out.LogLevel = skyenv.DefaultLogLevel
	out.ShutdownTimeout = visorconfig.DefaultTimeout
	out.RestartCheckDelay = restart.DefaultCheckDelay.String()
	out.Launcher = &visorconfig.V1Launcher{
		Discovery: nil,
		Apps: []launcher.AppConfig{
			{
				Name:      skyenv.SkychatName,
				AutoStart: true,
				Port:      routing.Port(skyenv.SkychatPort),
				Args:      []string{"-addr", skyenv.SkychatAddr},
			},
			{
				Name:      skyenv.SkysocksName,
				AutoStart: true,
				Port:      routing.Port(skyenv.SkysocksPort),
				Args:      skysocksArgs(),
			},
			{
				Name:      skyenv.SkysocksClientName,
				AutoStart: false,
				Port:      routing.Port(skyenv.SkysocksClientPort),
				Args:      []string{"-addr", skyenv.SkysocksClientAddr},
			},
			{
				Name:      "vpn-server",
				AutoStart: false,
				Port:      routing.Port(44),
			},
			{
				Name:      "vpn-client",
				AutoStart: false,
				Port:      routing.Port(43),
			},
		},
		ServerAddr: skyenv.DefaultAppSrvAddr,
		BinPath:    "/usr/bin/apps",
		LocalPath:  "/var/skywire-visor/apps",
	}
	return out, nil
}

func generateHypervisorConfig(conf Config, bp boot.Params) (interface{}, error) {
	pk, sk, err := genKeyPair(bp)
	if err != nil {
		return nil, err
	}
	out := new(hypervisor.Config)
	out.PK = pk
	out.SK = sk
	out.DBPath = "/var/skywire-hypervisor/users.db"
	out.EnableAuth = true
	out.Cookies.BlockKey = cipher.RandByte(32)
	out.Cookies.HashKey = cipher.RandByte(64)
	out.Cookies.FillDefaults()
	out.DmsgDiscovery = skyenv.DefaultDmsgDiscAddr
	out.DmsgPort = skyenv.DmsgHypervisorPort
	out.HTTPAddr = ":8000"
	out.EnableTLS = false // TODO(evanlinjin): TLS is disabled due to a bug in the skyminer Router.
	out.TLSCertFile = conf.TLSCert
	out.TLSKeyFile = conf.TLSKey
	err = GenCert(out.TLSCertFile, out.TLSKeyFile)
	return out, err
}
